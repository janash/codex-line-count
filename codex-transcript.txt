› How many lines of code is this project? Break down by language


• I’ll compute this directly from the repository and give you a language-by-
  language LOC breakdown. I’m checking for a standard counter first (cloc/tokei)
  so the numbers are reliable.

• Ran command -v tokei || true
  └ (no output)

• Ran command -v scc || true
  └ (no output)

• Ran command -v cloc || true
────────────────────────────────────────────────────────────────────────────────

  extension-to-language map and aggregating line counts per language.

• Ran cd /home/jessica-nash/jessica/mdtraj && rg --files -0 | while IFS= read -r
  │ -d '' f; do
  │ … +24 lines
  └ TOTAL    77583
    Python    46930
    … +9 lines
    JSON    1
    Jupyter Notebook    3524

────────────────────────────────────────────────────────────────────────────────

• mdtraj has 77,583 total lines across tracked files with recognized language
  extensions.

  Breakdown by language:

  - Text: 482
  - Markdown: 183
  - TOML: 67
  - YAML: 30
  - Config: 6


› How did you determine this?


• I computed it directly from files in the repo using rg --files + wc -l:

  1. Listed all files with rg --files.
  2. Mapped file extensions to languages (e.g., .py -> Python, .pyx/.pxd/.pxi -> Cython, .c -> C, C/C++ headers/sources -> C++, etc.).
  3. Counted lines per file with wc -l.
  4. Summed by language using awk.

  So these are physical line counts by extension, not semantic “code-only” counts (unless filtered as I did in the follow-up).
  Also, no LOC tool (cloc, tokei, scc) was installed, so I used this explicit shell pipeline.


› Can you write a script that I an use to verify this?


• I’ll add a reusable script in the repo that reproduces the same extension-
  based LOC breakdown and prints both full totals and “code-only” totals. I’m
  checking where utility scripts live, then I’ll add it there with usage
  instructions.

• Explored
  └ List ls
    List rg --files
    Search (^|/)scripts?/|tools?/|bin/

────────────────────────────────────────────────────────────────────────────────

• I found no top-level utility script folder, so I’ll place this under devtools/
  as a standalone verifier script. Next I’ll implement it and make it
  executable.

• Explored
  └ List devtools

• Added devtools/loc_by_language.py (+163 -0)
      1 +#!/usr/bin/env python3
      2 +"""Count repository lines of code by language using extension mapping.
      3 +
      4 +This script reproduces the same approach used in the terminal:
      5 +- enumerate files from `rg --files` when available
      6 +- map extensions to language names
      7 +- count physical lines (newline count, like `wc -l`)
      8 +"""
      9 +
     10 +from __future__ import annotations
     11 +
     12 +import argparse
     13 +import os
     14 +import subprocess
     15 +import sys
     16 +from collections import defaultdict
     17 +from pathlib import Path
     18 +
     19 +
     20 +EXTENSION_MAP = {
     21 +    ".py": "Python",
     22 +    ".pyx": "Cython",
     23 +    ".pxd": "Cython",
     24 +    ".pxi": "Cython",
     25 +    ".c": "C",
     26 +    ".h": "C++",
     27 +    ".hpp": "C++",
     28 +    ".hh": "C++",
     29 +    ".hxx": "C++",
     30 +    ".cpp": "C++",
     31 +    ".cc": "C++",
     32 +    ".cxx": "C++",
     33 +    ".f90": "Fortran",
     34 +    ".f95": "Fortran",
     35 +    ".f03": "Fortran",
     36 +    ".f": "Fortran",
     37 +    ".sh": "Shell",
     38 +    ".bash": "Shell",
     39 +    ".ps1": "PowerShell",
     40 +    ".rst": "reStructuredText",
     41 +    ".md": "Markdown",
     42 +    ".toml": "TOML",
     43 +    ".yaml": "YAML",
     44 +    ".yml": "YAML",
     45 +    ".json": "JSON",
     46 +    ".ini": "Config",
     47 +    ".cfg": "Config",
     48 +    ".conf": "Config",
     49 +    ".cmake": "CMake",
     50 +    ".mk": "Makefile",
     51 +    ".ipynb": "Jupyter Notebook",
     52 +    ".txt": "Text",
     53 +}
     54 +
     55 +FILENAME_MAP = {
     56 +    "CMakeLists.txt": "CMake",
     57 +    "Makefile": "Makefile",
     58 +}
     59 +
     60 +CODE_LANGUAGES = {"Python", "C++", "Cython", "C", "Fortran"}
     61 +
     62 +
     63 +def run_file_list_command(root: Path, command: list[str]) -> list[Path]
          | None:
     64 +    try:
     65 +        proc = subprocess.run(command, cwd=root, check=True, capture_ou
         tput=True)
     66 +    except (subprocess.CalledProcessError, FileNotFoundError):
     67 +        return None
     68 +
     69 +    entries = [entry for entry in proc.stdout.split(b"\x00") if entry]
     70 +    return [Path(entry.decode("utf-8", errors="surrogateescape")) for e
         ntry in entries]
     71 +
     72 +
     73 +def list_files(root: Path) -> list[Path]:
     74 +    files = run_file_list_command(root, ["rg", "--files", "-0"])
     75 +    if files is not None:
     76 +        return files
     77 +
     78 +    files = run_file_list_command(root, ["git", "ls-files", "-z"])
     79 +    if files is not None:
     80 +        return files
     81 +
     82 +    out: list[Path] = []
     83 +    for dirpath, dirnames, filenames in os.walk(root):
     84 +        if ".git" in dirnames:
     85 +            dirnames.remove(".git")
     86 +        for filename in filenames:
     87 +            full = Path(dirpath) / filename
     88 +            out.append(full.relative_to(root))
     89 +    return out
     90 +
     91 +
     92 +def language_for_path(path: Path) -> str | None:
     93 +    name = path.name
     94 +    if name in FILENAME_MAP:
     95 +        return FILENAME_MAP[name]
     96 +    return EXTENSION_MAP.get(path.suffix.lower())
     97 +
     98 +
     99 +def count_newlines(path: Path) -> int:
    100 +    # Match `wc -l`: count newline bytes, not logical text lines.
    101 +    total = 0
    102 +    with path.open("rb") as fh:
    103 +        for chunk in iter(lambda: fh.read(1024 * 1024), b""):
    104 +            total += chunk.count(b"\n")
    105 +    return total
    106 +
    107 +
    108 +def format_table(rows: list[tuple[str, int]]) -> str:
    109 +    width = max(len(lang) for lang, _ in rows)
    110 +    return "\n".join(f"{lang:<{width}}  {lines:>8}" for lang, lines in
         rows)
    111 +
    112 +
    113 +def main() -> int:
    114 +    parser = argparse.ArgumentParser(description=__doc__)
    115 +    parser.add_argument(
    116 +        "--root",
    117 +        type=Path,
    118 +        default=Path(__file__).resolve().parents[1],
    119 +        help="Repository root (default: auto-detected project root).",
    120 +    )
    121 +    parser.add_argument(
    122 +        "--code-only",
    123 +        action="store_true",
    124 +        help="Print only code language totals (Python/C++/Cython/C/Fort
         ran).",
    125 +    )
    126 +    args = parser.parse_args()
    127 +
    128 +    root = args.root.resolve()
    129 +    if not root.exists():
    131 +        return 2
    132 +
    133 +    totals: dict[str, int] = defaultdict(int)
    135 +        lang = language_for_path(rel_path)
    136 +        if not lang:
    137 +            continue
    138 +        full_path = root / rel_path
    139 +        if not full_path.is_file():
    140 +            continue
    141 +        totals[lang] += count_newlines(full_path)
    143 +    if not totals:
    144 +        print("No matching files found.")
    145 +        return 1
    146 +
    147 +    if args.code_only:
    148 +        rows = sorted(
    149 +            ((lang, lines) for lang, lines in totals.items() if lang in
          CODE_LANGUAGES),
    150 +            key=lambda item: item[1],
    151 +            reverse=True,
    152 +        )
    153 +    else:
    154 +        rows = sorted(totals.items(), key=lambda item: item[1], reverse
         =True)
    155 +
    156 +    grand_total = sum(lines for _, lines in rows)
    157 +    rows.append(("TOTAL", grand_total))
    158 +    print(format_table(rows))
    159 +    return 0
    160 +
    161 +
    162 +if __name__ == "__main__":
    163 +    raise SystemExit(main())

────────────────────────────────────────────────────────────────────────────────

• I’ve added the script; now I’m making it executable and running it to verify
  it reproduces the same totals we reported.

• Ran cd /home/jessica-nash/jessica/mdtraj && chmod +x devtools/
  │ loc_by_language.py
  └ (no output)

• Ran cd /home/jessica-nash/jessica/mdtraj && ./devtools/loc_by_language.py
  │ --code-only
  └ Python     47093
    C++        14593
    Cython      4949
    C           4577
    TOTAL      71212

• Ran cd /home/jessica-nash/jessica/mdtraj && python devtools/loc_by_language.py
  └ Python               47093
    C++                  14593
    … +10 lines
    TOTAL                77923

────────────────────────────────────────────────────────────────────────────────

• The first run differed because the new script file itself is now part of the
  repo scan, and my initial implementation also counted nested */Makefile paths.
  I’m tightening it to match the original one-liner exactly and exclude the
  script itself by default so you can reproduce the earlier numbers.

• Edited devtools/loc_by_language.py (+11 -4)
     54
     55 -FILENAME_MAP = {
     55 +ROOT_FILENAME_MAP = {
     56      "CMakeLists.txt": "CMake",
        ⋮
     92  def language_for_path(path: Path) -> str | None:
     93 -    name = path.name
     94 -    if name in FILENAME_MAP:
     95 -        return FILENAME_MAP[name]
     93 +    if path.as_posix() in ROOT_FILENAME_MAP:
     94 +        return ROOT_FILENAME_MAP[path.as_posix()]
     95      return EXTENSION_MAP.get(path.suffix.lower())
    127 +        action="store_true",
    128 +        help="Include this script in counting when it is under --root."
         ,
    130      args = parser.parse_args()
    137      totals: dict[str, int] = defaultdict(int)
    138 +    self_path = Path(__file__).resolve()
        ⋮
    144 +        if not args.include_self and full_path.resolve() == self_path:

  └ Python               46930
    C++                  14593
    … +9 lines
    JSON                     1
    TOTAL                77583

• Ran cd /home/jessica-nash/jessica/mdtraj && python devtools/loc_by_language.py
  │ --include-self --code-only
  └ Python     47100
    C++        14593
    Cython      4949
    C           4577
    TOTAL      71219

• Ran cd /home/jessica-nash/jessica/mdtraj && python devtools/loc_by_language.py
  │ --code-only
  └ Python     46930
    C++        14593
    Cython      4949
    C           4577
    TOTAL      71049

• Explored
  └ List loc_by_language.py

────────────────────────────────────────────────────────────────────────────────

• Added a verifier script at devtools/loc_by_language.py.

  Use it like this:

  python devtools/loc_by_language.py
  python devtools/loc_by_language.py --code-only

  It reproduces the same numbers we discussed:

  - Full mapped total: 77,583
  - Code-only total: 71,049

  Notes:

  - It uses the same extension mapping and wc -l-style newline counting.
  - It excludes itself by default so the totals match the earlier report.
  - If you want to include the script file in counts: --include-self.
